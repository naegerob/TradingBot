<!DOCTYPE html>
<html id="htmlId">
<head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
    <title>Coverage Report > IndicatorSnapshot</title>
    <style type="text/css">
        @import "../../css/coverage.css";
        @import "../../css/idea.min.css";
    </style>
    <script src="../../js/highlight.min.js" type="text/javascript"></script>
    <script src="../../js/highlightjs-line-numbers.min.js" type="text/javascript"></script>
</head>

<body>
<div class="content">
    <div class="breadCrumbs">
        Current scope: <a href="../../index.html">all classes</a>
        <span class="separator">|</span>
        <a href="../index.html">com.example.tradingLogic</a>
    </div>

    <h1>Coverage Summary for Class: IndicatorSnapshot (com.example.tradingLogic)</h1>

    <table class="coverageStats">
        <tr>
            <th class="name">Class</th>
            <th class="coverageStat
">
                Class, %
            </th>
            <th class="coverageStat
">
                Method, %
            </th>
            <th class="coverageStat
">
                Line, %
            </th>
        </tr>
        <tr>
            <td class="name">IndicatorSnapshot</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/1)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/1)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/10)
  </span>
            </td>
        </tr>

    </table>

    <br/>
    <br/>


    <pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.example.tradingLogic
&nbsp;
&nbsp;import com.example.data.singleModels.StockBar
&nbsp;import java.math.RoundingMode
&nbsp;import java.text.DecimalFormat
&nbsp;import kotlin.math.pow
&nbsp;
<b class="nc">&nbsp;data class IndicatorSnapshot(</b>
<b class="nc">&nbsp;    val originalPrice: Double,</b>
<b class="nc">&nbsp;    val resistance: Double,</b>
<b class="nc">&nbsp;    val support: Double,</b>
<b class="nc">&nbsp;    val averageBollingerBand: Double,</b>
<b class="nc">&nbsp;    val lowerBollingerBand: Double,</b>
<b class="nc">&nbsp;    val upperBollingerBand: Double,</b>
<b class="nc">&nbsp;    val shortSMA: Double,</b>
<b class="nc">&nbsp;    val longSMA: Double,</b>
<b class="nc">&nbsp;    val rsi: Double</b>
&nbsp;)
&nbsp;
&nbsp;class Indicators {
&nbsp;
&nbsp;    var mStock = &quot;&quot;
&nbsp;
&nbsp;    var mOriginalPrices = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;
&nbsp;    var mResistances = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;    var mSupports = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;
&nbsp;    var mAverageBollingerBand = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;    var mLowerBollingerBand = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;    var mUpperBollingerBand = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;
&nbsp;    var mShortSMA = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;    var mLongSMA = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;    var mRsi = mutableListOf&lt;Double&gt;()
&nbsp;        private set
&nbsp;
&nbsp;    fun updateIndicators(historicalBars: List&lt;StockBar&gt;) {
&nbsp;        val closingPrices: List&lt;Double&gt; = historicalBars.map { it.close }
&nbsp;        mOriginalPrices = closingPrices.toMutableList()
&nbsp;        // TODO: refactoring
&nbsp;        calculateSupportLevels(closingPrices)
&nbsp;        calculateResistanceLevels(closingPrices)
&nbsp;        calculateBollingerBands(closingPrices)
&nbsp;        calculateRsi(closingPrices)
&nbsp;        calculateShortSMA(closingPrices)
&nbsp;        calculateLongSMA(closingPrices)
&nbsp;        // trim all to shortest
&nbsp;        trimListsToShortest()
&nbsp;        println(mStock)
&nbsp;        println(mOriginalPrices)
&nbsp;        println(mOriginalPrices.size)
&nbsp;        println(mResistances)
&nbsp;        println(mResistances.size)
&nbsp;        println(mSupports)
&nbsp;        println(mSupports.size)
&nbsp;        println(mShortSMA)
&nbsp;        println(mShortSMA.size)
&nbsp;        println(mLongSMA)
&nbsp;        println(mLongSMA.size)
&nbsp;        println(mAverageBollingerBand)
&nbsp;        println(mAverageBollingerBand.size)
&nbsp;        println(mLowerBollingerBand)
&nbsp;        println(mLowerBollingerBand.size)
&nbsp;        println(mUpperBollingerBand)
&nbsp;        println(mUpperBollingerBand.size)
&nbsp;        println(mRsi)
&nbsp;        println(mRsi.size)
&nbsp;        println(&quot;H&quot;)
&nbsp;        // TODO: Check calculation properly
&nbsp;    }
&nbsp;
&nbsp;    private fun calculateSupportLevels(prices: List&lt;Double&gt;) {
&nbsp;        mSupports.clear()
&nbsp;        var lastSupport = prices.first()
&nbsp;        for (i in 1 until prices.lastIndex) {
&nbsp;            if (prices[i] &lt; prices[i - 1] &amp;&amp; prices[i] &lt; prices[i + 1]) {
&nbsp;                lastSupport = prices[i]
&nbsp;            }
&nbsp;            mSupports.add(lastSupport)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun calculateResistanceLevels(prices: List&lt;Double&gt;) {
&nbsp;        mResistances.clear()
&nbsp;        var lastResistance = prices.first()
&nbsp;        for (i in 1 until prices.lastIndex) {
&nbsp;            if (prices[i] &gt; prices[i - 1] &amp;&amp; prices[i] &gt; prices[i + 1]) {
&nbsp;                lastResistance = prices[i]
&nbsp;            }
&nbsp;            mResistances.add(lastResistance) // Local maximum (resistance)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun calculateRsi(prices: List&lt;Double&gt;, period: Int = 14) {
&nbsp;        mRsi.clear()
&nbsp;        val gains = mutableListOf&lt;Double&gt;()
&nbsp;        val losses = mutableListOf&lt;Double&gt;()
&nbsp;
&nbsp;        // Calculate initial gains and losses
&nbsp;        for (i in 1 until period) {
&nbsp;            val delta = prices[i] - prices[i - 1]
&nbsp;            if (delta &gt; 0) {
&nbsp;                gains.add(delta)
&nbsp;            } else {
&nbsp;                losses.add(-delta)
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Compute first average gain and loss
&nbsp;        var averageGain = gains.average()
&nbsp;        var averageLoss = losses.average()
&nbsp;
&nbsp;        // Compute RSI using exponential smoothing
&nbsp;        for (i in period until prices.size) {
&nbsp;            val delta = prices[i] - prices[i - 1]
&nbsp;            val gain = if (delta &gt; 0) delta else 0.0
&nbsp;            val loss = if (delta &lt; 0) -delta else 0.0
&nbsp;
&nbsp;            // Smoothed averages
&nbsp;            averageGain = ((averageGain * (period - 1)) + gain) / period
&nbsp;            averageLoss = ((averageLoss * (period - 1)) + loss) / period
&nbsp;
&nbsp;            val rs = if (averageLoss == 0.0) Double.POSITIVE_INFINITY else averageGain / averageLoss
&nbsp;            val rsi = 100 - (100 / (1 + rs))
&nbsp;            val df = DecimalFormat(&quot;#.##&quot;)
&nbsp;            df.roundingMode = RoundingMode.CEILING
&nbsp;            val roundedRsi = df.format(rsi).toDouble()
&nbsp;
&nbsp;            mRsi.add(roundedRsi)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // clears the lists, if prices.size &lt; window
&nbsp;    private fun calculateBollingerBands(prices: List&lt;Double&gt;, period: Int = 20, stdDevMultiplier: Double = 2.0) {
&nbsp;        mAverageBollingerBand.clear()
&nbsp;        mUpperBollingerBand.clear()
&nbsp;        mLowerBollingerBand.clear()
&nbsp;        for (i in period until prices.size) {
&nbsp;            if (i &gt;= period - 1) {
&nbsp;                val window = prices.subList(i - period + 1, i + 1)
&nbsp;
&nbsp;                val sma = window.average()
&nbsp;                val df = DecimalFormat(&quot;#.##&quot;)
&nbsp;                df.roundingMode = RoundingMode.CEILING
&nbsp;                val roundedSma = df.format(sma).toDouble()
&nbsp;                mAverageBollingerBand.add(roundedSma)
&nbsp;
&nbsp;                val stdDev = kotlin.math.sqrt(window.sumOf { (it - sma).pow(2) } / period)
&nbsp;
&nbsp;                val lowerRounded = df.format(roundedSma - stdDevMultiplier * stdDev).toDouble()
&nbsp;                val upperRounded = df.format(roundedSma + stdDevMultiplier * stdDev).toDouble()
&nbsp;                mUpperBollingerBand.add(upperRounded)
&nbsp;                mLowerBollingerBand.add(lowerRounded)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun trimListsToShortest() {
&nbsp;        val allLists = listOf(
&nbsp;            mLowerBollingerBand,
&nbsp;            mUpperBollingerBand,
&nbsp;            mAverageBollingerBand,
&nbsp;            mOriginalPrices,
&nbsp;            mRsi,
&nbsp;            mSupports,
&nbsp;            mResistances,
&nbsp;            mShortSMA,
&nbsp;            mLongSMA
&nbsp;        )
&nbsp;        val minSize = allLists.minOf { it.size }
&nbsp;        allLists.forEach { list -&gt;
&nbsp;            while (list.size &gt; minSize) {
&nbsp;                list.subList(0, list.size - minSize).clear() // Remove from the front
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun calculateShortSMA(prices: List&lt;Double&gt;, period: Int = 20) {
&nbsp;        mShortSMA.clear()
&nbsp;        for (i in period until prices.size) {
&nbsp;            if (i &gt;= period - 1) {
&nbsp;                val window = prices.subList(i - period + 1, i + 1)
&nbsp;
&nbsp;                val sma = window.average()
&nbsp;                val df = DecimalFormat(&quot;#.##&quot;)
&nbsp;                df.roundingMode = RoundingMode.CEILING
&nbsp;                val roundedSma = df.format(sma).toDouble()
&nbsp;                mShortSMA.add(roundedSma)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun calculateLongSMA(prices: List&lt;Double&gt;, period: Int = 50) {
&nbsp;        mLongSMA.clear()
&nbsp;        for (i in period until prices.size) {
&nbsp;            if (i &gt;= period - 1) {
&nbsp;                val window = prices.subList(i - period + 1, i + 1)
&nbsp;
&nbsp;                val sma = window.average()
&nbsp;                val df = DecimalFormat(&quot;#.##&quot;)
&nbsp;                df.roundingMode = RoundingMode.CEILING
&nbsp;                val roundedSma = df.format(sma).toDouble()
&nbsp;                mLongSMA.add(roundedSma)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun getValue(list: List&lt;Double&gt;, index: Int?): Double {
&nbsp;        return if (list.isNotEmpty()) {
&nbsp;            index?.takeIf { it in list.indices }?.let { list[it] } ?: list.last()
&nbsp;        } else {
&nbsp;            0.0
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun getIndicatorPoints(index: Int? = null): IndicatorSnapshot {
&nbsp;        return IndicatorSnapshot(
&nbsp;            originalPrice = getValue(mOriginalPrices, index),
&nbsp;            resistance = getValue(mResistances, index),
&nbsp;            support = getValue(mSupports, index),
&nbsp;            averageBollingerBand = getValue(mAverageBollingerBand, index),
&nbsp;            lowerBollingerBand = getValue(mLowerBollingerBand, index),
&nbsp;            upperBollingerBand = getValue(mUpperBollingerBand, index),
&nbsp;            shortSMA = getValue(mShortSMA, index),
&nbsp;            longSMA = getValue(mLongSMA, index),
&nbsp;            rsi = getValue(mRsi, index)
&nbsp;        )
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
    (function() {
        var msie = false, msie9 = false;
        /*@cc_on
          msie = true;
          @if (@_jscript_version >= 9)
            msie9 = true;
          @end
        @*/

        if (!msie || msie && msie9) {
          hljs.highlightAll()
          hljs.initLineNumbersOnLoad();
        }
    })();
</script>

<div class="footer">

    <div style="float:right;">generated on 2025-03-24 07:17</div>
</div>
</body>
</html>
